from __future__ import annotations

from typing import (
    TYPE_CHECKING,
    Any,
    Sequence,
    cast,
)

from sqlalchemy import func, select

from .construction import QuerySetConstruction, T

if TYPE_CHECKING:
    from sqlalchemy.ext.asyncio import AsyncSession
    from sqlalchemy.sql import ColumnElement, Select

    from flash_db.expressions import Resolvable


class QuerySetExecution(QuerySetConstruction[T]):
    """
    Runs the query and returns the results.

    This layer handles the actual database communication. It executes the
    SQL statement and converts the results into model instances or raw data
    like dictionaries and lists.
    """

    async def fetch(self, db: AsyncSession) -> Sequence[T]:
        """
        Execute the query and return results as a sequence of model instances.

        This method triggers the deferred SQL execution. If annotations are present,
        it performs row-to-object mapping, attaching calculated SQL values (like
        Counts or Sums) directly to the model instances.

        Args:
            db: The asynchronous SQLAlchemy session used to execute the statement.

        Returns:
            A sequence of model instances. Each instance is unique within the
            result set.

        Notes:
            - Uses `.unique()` to ensure primary key identity when joining
              multiple tables.
            - Annotations are injected using `setattr` and are not persisted to the
              underlying table unless specifically saved.

        Examples:
            >>> # Basic fetch
            >>> articles = await Article.objects.filter(status="published").fetch(db)
            >>>
            >>> # Fetch with annotations
            >>> qs = Article.objects.annotate(comment_count=Count("comments"))
            >>> articles = await qs.fetch(db)
            >>> print(articles[0].comment_count)  # Accesses the calculated field
        """
        result = await db.execute(self._stmt)

        # FAST PATH: When no annotations (calculated fields) are present, the
        # result set contains only the primary Model objects. .scalars() unwraps
        # the single-element rows into Model instances directly.
        if not self._annotations:
            # .unique() is mandatory when using joined eager loading to ensure
            # SQLAlchemy returns a single object instance for each DB identity,
            # even if multiple SQL rows were generated by the JOIN.
            return result.scalars().unique().all()

        # COMPOSITE MAPPING: When annotations are added (e.g. .annotate(n=Count('id'))),
        # SQLAlchemy returns rows as composite structures: (ModelInstance, extra_val...)
        #
        # Example SQL Generated:
        #     SELECT users.*, COUNT(posts.id) AS post_count
        #     FROM users LEFT JOIN posts ON ... GROUP BY users.id;
        #
        # Actual row._mapping structure:
        #     {
        #         User: <User(id=1, name="Aung")>,  # Identity-keyed ORM object
        #         "post_count": 5                  # Label-keyed scalar value
        #     }
        #
        # We must deduplicate these composite rows by identity and then manually
        # attach the computed aggregate values back to the model instance.
        rows = result.unique().all()
        objects: list[T] = []
        for row in rows:
            mapping = row._mapping
            # mapping[self.model] correctly extracts the ORM instance
            # from composite rows.
            instance = cast("T", mapping[cast("Any", self.model)])

            for key in self._annotations:
                # Inject the calculated SQL values as transient attributes.
                # These attributes are available for logic/serialization but
                # are not tracked by SQLAlchemy's Unit of Work for persistence.
                setattr(instance, key, mapping[key])
            objects.append(instance)

        return objects

    async def first(self, db: AsyncSession) -> T | None:
        """
        Execute query and return the first result or None.

        Example:
            >>> article = await Article.objects.first(db)
            # SELECT * FROM articles LIMIT 1;
        """
        stmt = self._stmt.limit(1)
        result = await db.execute(stmt)

        if not self._annotations:
            return result.scalars().unique().one_or_none()

        row = result.unique().one_or_none()
        if not row:
            return None

        # Model instance is correctly mapped via row._mapping in composite result rows.
        mapping = row._mapping
        instance = cast("T", mapping[cast("Any", self.model)])
        for key in self._annotations:
            setattr(instance, key, mapping[key])
        return instance

    async def last(self, db: AsyncSession) -> T | None:
        """
        Return the last record by primary key descending.

        Example:
            >>> await Article.objects.last(db)
            # SELECT * FROM articles ORDER BY id DESC LIMIT 1;
        """
        return await self.order_by(self.model.id.desc()).first(db)

    async def latest(self, db: AsyncSession, field: str = "created_at") -> T | None:
        """
        Return the latest object in the table based on the given field.

        Example:
            >>> article = await Article.objects.latest(db)
            # SELECT * FROM articles ORDER BY created_at DESC LIMIT 1;
        """
        return await self.order_by(getattr(self.model, field).desc()).first(db)

    async def earliest(self, db: AsyncSession, field: str = "created_at") -> T | None:
        """
        Return the earliest object in the table based on the given field.

        Example:
            >>> article = await Article.objects.earliest(db)
            # SELECT * FROM articles ORDER BY created_at ASC LIMIT 1;
        """
        return await self.order_by(getattr(self.model, field).asc()).first(db)

    def _build_projection_stmt(self, *fields: str) -> Select:
        """
        DRY helper using Select.with_only_columns to avoid private attribute access.
        """
        if not fields:
            # Fallback to all columns if no specific fields are requested.
            cols = list(self.model.__table__.columns)
        else:
            cols = []
            for f in fields:
                # We prioritize _annotations mapping. This allows users to retrieve
                # calculated fields (e.g., from .annotate()) by their alias name.
                if f in self._annotations:
                    cols.append(self._annotations[f])
                else:
                    cols.append(getattr(self.model, f))

        # with_only_columns is the standard SQLAlchemy way to re-project a query
        # while preserving filters, joins, grouping, and ordering.
        return self._stmt.with_only_columns(*cols, maintain_column_froms=True)

    async def values(self, db: AsyncSession, *fields: str) -> list[dict[str, Any]]:
        """
        Return results as a list of dictionaries.

        This method bypasses model instance creation and returns raw data
        mapped to dictionaries. It's useful for performance-sensitive read
        operations or when only specific fields are needed.

        Args:
            db: The asynchronous SQLAlchemy session.
            *fields: Specific field names to include. If empty, all model
                columns are included.

        Returns:
            A list of dictionaries where keys are field names and values are
            the database values.

        Notes:
            - Supports both model columns and previously defined annotations.
            - Reconstructs a new SELECT statement while preserving existing
              where, having, group_by, and order_by clauses.

        Examples:
            >>> # Get specific fields
            >>> data = await Article.objects.values(db, "title", "id")
            >>>
            >>> # Get all fields
            >>> all_data = await Article.objects.values(db)
        """
        stmt = self._build_projection_stmt(*fields)
        result = await db.execute(stmt)

        # RowMapping objects provide a dictionary-like interface to the results.
        # We explicitly convert them to standard dicts to decouple the output
        # from SQLAlchemy's internal row types.
        return [dict(row._mapping) for row in result]

    async def values_list(
        self, db: AsyncSession, *fields: str, flat: bool = False
    ) -> list[Any]:
        """
        Return results as a list of tuples or flat values.

        Similar to `values()`, but returns tuples instead of dictionaries.
        If `flat=True` is passed, returns a list of single values instead
        of tuples.

        Args:
            db: The asynchronous SQLAlchemy session.
            *fields: Specific field names to include.
            flat: If True, returns a list of values instead of tuples. Only
                valid when a single field is requested.

        Returns:
            A list of tuples (or values if flat=True) containing the requested
            database data.

        Raises:
            ValueError: If flat=True is used with more than one field.

        Notes:
            - Like `values()`, this reconstructs a new SELECT statement to
              avoid model instance overhead.

        Example:
            >>> titles = await Article.objects.values_list(db, "title", flat=True)
            >>> # ['Hello', 'World']
            >>>
            >>> data = await Article.objects.values_list(db, "id", "title")
            >>> # [(1, 'Hello'), (2, 'World')]
        """
        if flat and len(fields) != 1:
            msg = "flat=True can only be used with a single field"
            raise ValueError(msg)

        stmt = self._build_projection_stmt(*fields)
        result = await db.execute(stmt)

        if flat:
            # scalars() returns the first column of each row directly.
            return list(result.scalars().all())

        return [tuple(row) for row in result]

    async def count(self, db: AsyncSession) -> int:
        """
        Return total record count for the QuerySet.

        Example:
            >>> count = await Article.objects.count(db)
            # SELECT count(*) FROM (SELECT * FROM articles) AS subquery;
        """
        # Wrapped in a subquery to support DISTINCT and GROUP BY accurately.
        count_stmt = select(func.count()).select_from(self._stmt.subquery())
        return await db.scalar(count_stmt) or 0

    async def exists(self, db: AsyncSession) -> bool:
        """Check if any records exist matching the query."""
        from sqlalchemy import exists as sa_exists

        # Optimized existence check using SQL EXISTS.
        stmt = select(sa_exists(self._stmt.limit(1).subquery()))
        return await db.scalar(stmt) or False

    async def aggregate(
        self, db: AsyncSession, **kwargs: ColumnElement[Any] | Resolvable
    ) -> dict[str, Any]:
        """
        Runs the summary query.

        If the query has groups (like from annotate), it uses a subquery
        to get the total across all groups.
        """
        if not kwargs:
            return {}

        from flash_db.expressions import Aggregate, Resolvable

        # If the query is already grouped, has HAVING, DISTINCT, or LIMIT/OFFSET,
        # we must aggregate over a subquery to get a single summary result.
        if (
            self._group_by_clauses
            or self._having_criteria
            or self._distinct
            or self._limit_clause is not None
            or self._offset_clause is not None
        ):
            subq = self._stmt.subquery()
            agg_cols = []
            for key, expr in kwargs.items():
                if isinstance(expr, Aggregate):
                    # Resolve the aggregate first to handle relationships/fields
                    # We pass the model to get the correct column/expression
                    # But for the subquery, we need to target the column in the subquery
                    # corresponding to the field name.

                    # NOTE: Aggregate.resolve() returns a function (e.g. count(col)).
                    # We need to construct a new aggregate over the SUBQUERY column.
                    # The subquery should already contain the columns needed.
                    # If it's a simple field, it will be in subq.c.
                    col = getattr(subq.c, expr.field)
                    agg_cols.append(getattr(func, expr._func_name)(col).label(key))
                elif isinstance(expr, Resolvable):
                    # Handle other Resolvables (like F expressions) in the subquery
                    # context. We pass the model to get the correct column/expression.
                    # A robust implementation would require re-mapping resolved
                    # expressions to the subquery. For now, we resolve and append.
                    resolved = expr.resolve(self.model, _annotations=self._annotations)
                    if resolved is not None:
                        agg_cols.append(resolved.label(key))
                else:
                    # Fallback for raw SQLAlchemy expressions
                    agg_cols.append(cast("ColumnElement[Any]", expr).label(key))
            stmt = select(*agg_cols)
        else:
            # Simple case: just change the selected columns
            agg_cols = []
            for key, expr in kwargs.items():
                if isinstance(expr, Resolvable):
                    resolved = expr.resolve(self.model, _annotations=self._annotations)
                    if resolved is not None:
                        agg_cols.append(resolved.label(key))
                else:
                    agg_cols.append(cast("ColumnElement[Any]", expr).label(key))

            stmt = self._stmt.with_only_columns(*agg_cols, maintain_column_froms=True)

            for expr in kwargs.values():
                if isinstance(expr, Aggregate):
                    for join_attr in expr.get_joins(self.model):
                        stmt = stmt.outerjoin(join_attr)

        result = await db.execute(stmt)
        mapping = result.mappings().first()
        return dict(mapping) if mapping else dict.fromkeys(kwargs, None)
